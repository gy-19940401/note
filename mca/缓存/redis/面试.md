# 1、redis 

## 1、redis 为什么快，TPS/QPS

~~~
1、基于内存
2、核心处理逻辑基于 单线程 没有线程切换
3、I/O 多路复用（Epoll）{
	select：仅仅知道有 IO 事件，却不知道那些流，只能轮询
	poll：本质上与 select 一样 只是没得最大连接数的限制
	epoll：epoll会把 完成的 流IO 通知给 处理模块。
	}
4、数据结构{
	1、string
	2、hash
	3、list
	4、set
	5、Zset
}
5、计算向数据移动（在 IO 上优化）


TPS/QPS --> 4W 
	1、value 体积相关
    2、value 类型
    
解决项目问题
	1、（动静分离）缓存：（腾出数据库 QPS 给业务）减轻数据库压力
	2、涉及一直性问题：
~~~

## 2、redis 内存不够用

~~~
1、压缩
2、value 类型的梳理
3、虚拟内存
~~~

## 3、redis 解决主从延迟

~~~
1、不能 完全解决
2、配置中开启
	slaves 的数量
	time 时间
~~~

## 4、不同物理机房

~~~
1、
2、near cache ：备份/异地多活
3、数据库层面做同步
~~~

## 5、存储 + 缓存

~~~
1、淘汰策略
	1、redis 的淘汰策略
	2、过期集合的淘汰（LFU/LFRU）
~~~

## 6、redis 的 I/O 模型 ，单/多线程

~~~
1、redis : i/o epoll io threads 是 多线程，核心业务处理是 单线程
	循环一次 查出 完成的 I/O 
~~~

## 7、redis 代理模式？

~~~
1、AKF 
2、cluster 的痛点
~~~

## 8、AKF 实现 Z 轴 数据分治

~~~
1、Z 轴 做 sharding 分片
2、cluster + hash tag
3、代理 client
~~~

## 9、redis 主从复制 读写分离

~~~
1、读写分离，禁用 关注一致性 主从都需要关闭

2、没有一致性问题 读写分离。

补：
	1、哨兵的主从 怎么配置从节点
		1、哨兵配置 master 通过 发布订阅 哨兵之间发现 从节点
		2、通过 master 的 info 学习到从节点，以备切换
~~~

## 10、保证 热点数据

~~~
0、前期活动 涉及到的大数据
1、热数据不能被预测
2、解决 {
	雪崩：redis缓存中大量的key同时失效，此时又刚好有大量的请求打进来
		事先：
			原有的失效时间基础上增加一个随机值，
			通过锁控制一定时间只有一个线程获取到资源从数据库拿到数据后写回缓存
		事中：限流 + 降级
    穿透：查询一个缓存和数据库都不存在的数据，导致尽管数据不存在但是每次都会到数据库查询
    	查询返回的数据为空，我们仍然把这个空结果进行缓存
    	布隆过滤器，将所有可能存在的数据hash到一个足够大的bitmap中。
    击穿：单个key值的缓存失效过期
    	若缓存数据基本不会发生更新，则可尝试将热点数据设置为永不过期。
    	缓存刷新快：加锁保证少量线程访问数据库
    	缓存刷新慢：定时任务定时刷新
    }

3、拿锁去查询数据库 ，减少 无效请求 ，快速熔断 无效的 key 
~~~

## 11、redis 做秒杀（3.3 日 redis）

~~~
1、redis 做库存扣减 过滤，筛选 无效请求。
2、
~~~

## 12、双写一致性

~~~
读：不存在
写：
	1、直写：cache-write-through ( 先写缓存 - 再写给数据库 ) 
	2、回写：cache-write-behand:数据库异写：MQ (数据库 回更)
~~~


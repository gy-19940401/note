# 1、基本信息

~~~
1、基本类型
	1、string
	2、list
	3、hash
	4、set
	5、zset
2、底层数据结构(算法 临界值)
	string : sds
	list : zplist quickList
	hash : hash dict
	set  : intset hash
	zset : (长整型512) (个数128长度64字节) skipList
3、持久化
	AOF ： 增量 操作记录
	RDB ： 二进制日志 
4、淘汰策略
	1、LRU : 时效性问题 某一时刻 很多数据写到缓存 存频率
	2、LFU : 16(时间) + 8(频率)
5、过期策略
	1、主动过期
		1、查询时判断是否设置过期时间
	2、被动过期
		1、设置过期时间 hash桶（数据结构）20个 
6、分布式锁
7、穿透 击穿 雪崩
8、哨兵 主从 集群
~~~



# 2、redis 

## 1、redis 为什么快，TPS/QPS

~~~
1、基于内存
2、核心处理逻辑基于 单线程 没有线程切换
3、I/O 多路复用（Epoll）{
	select：仅仅知道有 IO 事件，却不知道那些流，只能轮询
	poll：本质上与 select 一样 只是没得最大连接数的限制
	epoll：epoll会把 完成的 流IO 通知给 处理模块。
	}
4、数据结构{
	1、string
	2、hash
	3、list
	4、set
	5、Zset
}
5、计算向数据移动（在 IO 上优化）


TPS/QPS --> 4W 
	1、value 体积相关
    2、value 类型
    
解决项目问题
	1、（动静分离）缓存：（腾出数据库 QPS 给业务）减轻数据库压力
	2、涉及一直性问题：
~~~

## 2、redis 内存不够用

~~~
1、压缩
2、value 类型的梳理
3、虚拟内存
~~~

## 3、redis 解决主从延迟

~~~
1、不能 完全解决
2、配置中开启
	slaves 的数量
	time 时间
~~~

## 4、不同物理机房

~~~
1、
2、near cache ：备份/异地多活
3、数据库层面做同步
~~~

## 5、存储 + 缓存

~~~
1、淘汰策略
	1、redis 的淘汰策略
	2、过期集合的淘汰（LFU/LFRU）
~~~

## 6、redis 的 I/O 模型 ，单/多线程

~~~
1、redis : i/o epoll io threads 是 多线程，核心业务处理是 单线程
	循环一次 查出 完成的 I/O 
~~~

## 7、redis 代理模式？

~~~
1、AKF 
2、cluster 的痛点
~~~

## 8、AKF 实现 Z 轴 数据分治

~~~
1、Z 轴 做 sharding 分片
2、cluster + hash tag
3、代理 client
~~~

## 9、redis 主从复制 读写分离

~~~
1、读写分离，禁用 关注一致性 主从都需要关闭

2、没有一致性问题 读写分离。

补：
	1、哨兵的主从 怎么配置从节点
		1、哨兵配置 master 通过 发布订阅 哨兵之间发现 从节点
		2、通过 master 的 info 学习到从节点，以备切换
~~~

## 10、保证 热点数据

~~~
0、前期活动 涉及到的大数据
1、热数据不能被预测
2、解决 {
	雪崩：redis缓存中大量的key同时失效，此时又刚好有大量的请求打进来
		事先：
			原有的失效时间基础上增加一个随机值，
			通过锁控制一定时间只有一个线程获取到资源从数据库拿到数据后写回缓存
		事中：限流 + 降级
    穿透：查询一个缓存和数据库都不存在的数据，导致尽管数据不存在但是每次都会到数据库查询
    	查询返回的数据为空，我们仍然把这个空结果进行缓存
    	布隆过滤器，将所有可能存在的数据hash到一个足够大的bitmap中。
    击穿：单个key值的缓存失效过期
    	若缓存数据基本不会发生更新，则可尝试将热点数据设置为永不过期。
    	缓存刷新快：加锁保证少量线程访问数据库
    	缓存刷新慢：定时任务定时刷新
    }

3、拿锁去查询数据库 ，减少 无效请求 ，快速熔断 无效的 key 
~~~

## 11、redis 做秒杀（3.3 日 redis）

~~~
1、redis 做库存扣减 过滤，筛选 无效请求。
2、
~~~

## 12、双写一致性（redis to cache）

~~~
读：不存在
写：
	1、直写：cache-write-through ( 先写缓存 - 再写给数据库 ) 
	2、先写数据库，再写缓存
	3、*先写数据库，再删缓存
	4、先写数据库，canal同步

volatile : 可见性
cpu的MESI : 
~~~

### 1、穿透，击穿，雪崩，预热（cache miss）

### 2、布隆过滤器

~~~
设置的值 不存在 set null 数量级很大时，对内存压力的问题

能够证明 没有，但不能证明有（可能有）
~~~



### 3、一致性的设计模式

#### 1、cache aside

#### 2、

~~~
1、缓存存热点数据
	写扩散：更新完数据库后，就同步更新缓存（未来发生并发的概率较大）
	读扩散：数据读取，发生 cache-miss 后更新数据
~~~



生产事故排查

## 13、分布式锁

![image-20221107202415886](C:\Users\CSB7D0\Desktop\mca\typroImage\image-20221107202415886.png)

### 1、redis 分布式锁

~~~
1、死锁 -- 过期时间
2、重复锁 -- 看门狗
3、锁的归属 -- lua脚本
4、重入锁 -- hash hset --lua

5、锁性能问题
	a、轮询 cas 去抢锁
	b、回调方式（基于 redis 的发布订阅）--订阅 redis 自身的事件 （remove key (redisson 已经实现); ）
	
6、单点故障 （可靠性问题）
	a、高可靠 -- 哨兵 -- 主从同步 -- 延迟
	b、分片集群 -- 压力问题 （16384）
	c、红锁 -- 解决单点故障问题（算法层面的实现）获取锁，过半获取证明抢到锁了（银行家算法）
		并发抢锁失败（重试）
		CAP -- P:分区容错
		对其 时间比较难计算
~~~

### 2、zookeeper 分布式锁（CP）

~~~
1、角色
	leader --负责 写入
	follower -- 负责读
2、性能 -- 不如单节点 redis
	zookeeper leader数据写入的损耗
	zk 集群的 2PC 提交的损耗
3、watch
	写入失败时，可以添加 watch,删除时，回调监听者；有序监听优化回调性能消耗
4、重入锁
	获得锁的时候，记录自己的信息，下次重入时判断
~~~


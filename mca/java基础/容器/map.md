# HashMap

# ConcurrentHashMap

## 1、结构

jdk1.7：数组+链表

jdk1.8：数组 + 链表 + 红黑树

## 2、为什么追加红黑树

~~~
1、链表时间复杂度 O(n) 链表过长，查询效率低
2、红黑树查询效率 O（logn）效率高。
~~~

## 3、链表树化的条件

~~~
1、数组元素长度 >=64 && 某一桶下元素达到 8
2、根据泊松分布，超过 8 的概率很低。
~~~

## 4、红黑树非树化的条件

~~~
1、链表长度变为 6 的时候
~~~

## 5、数组扩容时，线程数量为什么+1

~~~
sizeCtl 为 -1 时，代表 CHM 正在初始化，所以 有一个 扩容时就在原有基础上 加 1
~~~

## 6、散列算法

~~~
hash 值 向右移动 16 位，参与 散列运算 。从而打散 hash ;
	hash^(hash >>> 16) & 0x7fffffff 将 散列值 取绝对值。 
	负Hash 的含义 ：
		MOVED -1 当前数据已被迁移 ：正在迁移
		TREEBIN -2 当前索引位是一个红黑树 ： 
		RESERVED -3 当前索引  是一个已经有值 ： 

确定位置 基于 长度-1 & hash 值 计算位置
~~~

## 7、线程安全的方式

~~~
HashTable : 在方法上 加 synchrinized

JDK 1.7 : 分段锁计数（一个锁控制多个桶）

JDK 1.8 : 基于 CAS 的同步代码块
	1、如果当前位置 没有 数据，CAS 加入数据
	2、如果当前位置 有 数据 ，锁住当前桶 
~~~

## 8、扩容（尾插）

### 1、sizeCtl

~~~
=-1 当前 CHM 正在初始化
<-1 当前正在扩容
=0 还未初始化
>0 未初始化代表数组长度
   已经初始化 代表扩容阈值	
~~~

### 2、reSize

~~~

~~~



### 2、触发条件

~~~
1、数组达到扩容阈值（* 负载因子）
2、链表达到 8 ，但数组未达到 64 
3、putAll 判断是否需要扩容
~~~

### 3、扩容戳

~~~
多线程 put 时，如果当前正在扩容，业务线程 会加入 map 扩容的数据转移的过程。

保证 多个线程扩容的 长度 是一样的。值与 原数组长度绑定的值。
~~~

![image-20220816224049057](C:\Users\CSB7D0\Desktop\mca\typroImage\image-20220816224049057.png)

![image-20220816224854037](C:\Users\CSB7D0\Desktop\mca\typroImage\image-20220816224854037.png)

![image-20220816225217958](C:\Users\CSB7D0\Desktop\mca\typroImage\image-20220816225217958.png)
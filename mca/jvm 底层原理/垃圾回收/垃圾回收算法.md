# 垃圾回收

## 标记清除

### 标记

### 清除

### 空间分配

#### 首次适应

#### 邻近适应算法

#### 最佳适应算法

#### 最差适应算法

## 标记复制算法(复制压缩)

## 标记清除压缩算法

### 随机整理（双指针回收算法）

对象移动方式与引用关系无关。内存索引号

两个指针：一个指向空闲区块，一个找可达对象。指针碰撞时，将空闲部分释放。

两次遍历：第一次：移动位置，但是不更新标记。

​				   第二次：更新标记。其中的指针往前遍历，比较内存索引号。

缺点：

```
1. 将原本告诉的缓存行打乱。
2. 破坏局部性原理。
3. 只能处理固定大小的对象。
```

### 线性整理

将具有关联的放在一起

### 滑动整理（Lisp2算法，单次遍历算法）

将对象按原本的顺序滑动到一端

#### Lisp2 三指针算法

第一次遍历：

![](C:\Users\CSB7D0\Desktop\mca\typroImage\image-20220615221935509.png)

~~~
一个指针固定在尾部。
另外两个指针在头部。其中一个从头开始遍历到尾部。出现可达对象，另外一个对头指针移动可达对象的空间大小。
~~~

第二次遍历：

~~~
修改根对象的引用关系。
~~~

第三次遍历：

~~~
移动对象的位置。
~~~

#### 单次遍历算法

有一个表 记录内存块移动到的位置。（卡表？）

## 分代回收

### 弱分代假说：绝大多数对象 朝生夕死

### 强分代假说：经过越多次回收后的对象，越难消亡

### 跨分代假说：跨代引用占极少数
# 0.特点与定义

~~~
定义 ： 指一个类只有一个实例，且该类能自行创建这个实例的一种模式。
特点 ： 
    1、单例类只有一个实例对象；
    2、该单例对象必须由单例类自行创建；
    3、单例类对外提供一个访问该单例的全局访问点；
~~~

# 1、类图

![img](IdeaProject/note/mca/typroImage/singltin_class.png)

# 2、实现

## 1、饿汉式 （线程安全）

### 1.1 特点

~~~
类一旦加载就创建一个单例，保证在调用 getInstance 方法之前单例已经存在了
~~~

### 1.2 实现

~~~java
public class HungrySingleton {
    private static final HungrySingleton instance = new HungrySingleton();

    private HungrySingleton() {
    }

    public static HungrySingleton getInstance() {
        return instance;
    }
}
~~~

## 2、懒汉式

### 2.1类锁（Synchronized）

#### 2.1.1 特点

~~~
 是类加载时没有生成单例，只有当第一次调用 getlnstance 方法时才去创建这个单例。
~~~

### 2.1.2 代码实现

~~~java
public class LazySingleton {

    /**
     * 保证 instance 在所有线程中同步
     * volatile : 保证单列对象的内存可见性
     */
    private static volatile LazySingleton instance = null;

    /**
     * private 避免类在外部被实例化
     */
    private LazySingleton() {
    }

    /**
     * 保证线程安全
     */
    public static synchronized LazySingleton getInstance() {
        if (instance == null) {
            instance = new LazySingleton();
        }
        return instance;
    }
}
~~~

### 2.2 DCL

#### 2.2.1 特点

~~~
这种方式采用双锁机制，安全且在多线程情况下能保持高性能
~~~

#### 2.2.2 实现

~~~java
public class Singleton4 {

    /**
     * volatile 防止指令重拍 -- 内存可见性
     */
    private static volatile Singleton4 instance;

    private Singleton4() {
    }

    public static Singleton4 getInstance() {
        if (instance == null) {
            /**
             * synchronized 线程安全
             */
            synchronized (Singleton4.class) {
                if (instance == null) {
                    instance = new Singleton4();
                }
            }
        }

        return instance;
    }

}
~~~

## 3、静态内部类

### 3.1 特点

~~~
这种方式能达到双检锁方式一样的功效，但实现更简单。
静态域使用延迟初始化，应使用这种方式而不是双检锁方式。
~~~

### 3.2 实现

~~~java
public class Singleton {
    /**
     * 静态内部类
     * 基于 jvm 的 类加载机制，初始化 静态变量 一次
     */
    private static class HolderClass {
        private static final Singleton instance = new Singleton();
    }

    public static Singleton getInstance() {
        return HolderClass.instance;
    }
}
~~~

## 4 枚举

### 4.1 特点

~~~
枚举是天然的 单列，源于源码层面的保证
不会被反射
~~~

### 4.2 实现

~~~java
public enum Singleton6 {
    INSTANCE;

    public Singleton6 getInstance() {
        return INSTANCE;
    }
}
~~~

## 5、ThreadLocal 空间换时间的解决方式

### 5.1 特点

~~~
为每一个线程 分配一个变量，保证线程内 安全
不适用于跨线程的变量访问
~~~

### 5.2 实现

~~~java
public class Singleton8 {

    /**
     * threadLocal 的 匿名子类，
     * 重写 initialValue() 方法 -- Returns the current thread's "initial value" for this thread-local variable.
     */
    private static final ThreadLocal<Singleton8> tlSingleton = new ThreadLocal<Singleton8>() {
        @Override
        protected Singleton8 initialValue() {
            return new Singleton8();
        }
    };

    private Singleton8() {
    }

    public static Singleton8 getInstance() {
        return tlSingleton.get();
    }
}
~~~

## 6、基于 CAS 实现

### 6.1 特点

~~~
基于 CAS 的自旋操作
~~~

### 6.2 实现

~~~java
public class Singleton9 {

    private static final AtomicReference<Singleton9> INSTANCE = new AtomicReference<Singleton9>();

    private Singleton9() {
    }

    public static Singleton9 getInstance() {
        for (; ; ) {
            Singleton9 current = INSTANCE.get();

            if (current != null) {
                return current;
            }

            current = new Singleton9();

            /**
             * 基于 CAS 操作
             */
            if (INSTANCE.compareAndSet(null, current)) {
                return current;
            }
        }
    }

}
~~~